仿真一个简单的类似cpu的机器  
-------------------------  
>接到学校布置的任务，要用仿真软件画一个简单的能运行的cpu，要求8位字长，给定14种指令。
我花了10天左右来完成这个任务。这篇文章就记录一下我是如何从头开始画这个cpu（或者说类似cpu的机器）的。  

打开仿真软件，空空如也不知从何下手，总之先把印象中的“cpu数据通路图”画出来。
需要一个ALU，RAM，PC，IR，AR，两个ALU的DR，以及若干通用寄存器，这里我用了3个通用寄存器。  

RAM同时保存指令和数据（本质相同，都是二进制数），PC从0开始不停地增加1，这样RAM里的比特就会被一个一个读出来放到数据总线上（也有不经过PC的情况），
之后这些比特如果被IR从总线上读走，那么它们就是指令，否则就是数据。机器会按一定的顺序让IR或其他东西从总线上读比特，
比如IR先读一次，其他东西再读，其他东西读完之后，又轮到IR读一次。我们只要配合这个顺序，把相应的比特存进RAM，就能让机器按我们的想法运行。  

现在RAM里全是0，机器能从头到尾读一遍RAM，然后按自己的顺序把这些0交给IR或别的东西。
把比特交出去之后怎么办呢？PC应该暂停下来，先让这次的指令或数据被处理完，然后PC再从RAM里读下一串比特。
这就意味着：包括PC，RAM，IR，寄存器等等在内的所有东西，除了它们的数据输入端以外，别的输入端都应该由机器来控制，
而不是直接接电源或接地，或接上一个频率恒定的时钟。  

这大概就是控制信号，用来控制这些部件如何工作。  
要完成一个动作可能需要好几组控制信号，比如从RAM里取出比特，送给IR：  
（我没能理解T1,T2,T3,T4具体是如何工作的，只好自己想了个看上去容易实现的方法）  
>对照“数据通路图”看这个过程。  
>第1组、所有控制信号复位（置为无效，高有效的置0，低有效的置1）  
>第2组、PC的值放到总线（PC的输出三态门控制端置有效，别的信号同上复位状态）  
>3、AR从总线上取值，送到RAM地址端，PC三态门关上，RAM准备读操作（AR的时钟跳一个上升沿，PC三态门置无效，RAM读操作控制端置有效，别的信号同上）  
>4、RAM读出值放到总线（AR时钟复位，RAM片选信号置有效，别的信号同上）  
>5、IR拿走总线上的值，RAM关上（IR时钟一个上升沿，RAM片选信号置无效，别的信号同上）  
>6、所有信号复位  

上面的过程就是“取指”，“译码”。很明显这些控制信号是按顺序送出的，要实现这一点，则需要另一个计数器，不断加1，按顺序从ROM里读出控制信号，
然后直接送给PC，RAM等部件。像这样把取指译码和所有指令所需要的控制信号序列，存进一块ROM里（编个号，叫ROM1），每当取指译码完成，IR送来指令，
就把计数器置数为这条指令的第1组控制信号所在的地址，然后就会自动按顺序送出控制信号，这就是“执行”。  

除了停机指令HALT之外，一条指令执行完成后，紧接着又应该取指译码，简单起见，我直接在除HALT之外的每条指令的控制信号之后，又重复了一遍取指译码的控制信号。

至于如何根据指令获得第1组控制信号的地址，还是简单起见，我又拿了一块ROM（编号叫ROM2），直接把8位指令当做地址，控制信号的地址当做内容，存进去。
比如：MOV R0，R1这条指令是10000001，其第一组控制信号位于ROM1的00001001地址处，那就把00001001写入ROM2的10000001地址处。
这样，把8位指令直接送入ROM2的地址端，出来的就是第一组控制信号所在的地址，再用它给计数器置数，然后就会从这个地址开始自动按顺序送出控制信号。

把一个时钟接到计数器上，基本上大功告成了。还有一个问题：遇到HALT时，其后虽没有取指译码的控制信号，但计数器仍然会不断加1，而之后的地址处全是0，
于是送出了一堆0作为控制信号，这是不正确的。
我用D型触发器和几个逻辑门做了一个小电路，当8位指令是HALT时，让计数器控制端无效并锁存这个无效状态，不会再加1，这样就实现了停机。

还有一个问题：所有控制信号应该同时送出。为此我把控制信号都先接在了锁存器上，锁存器会在下一个时钟上升沿同时送出所有控制信号。

最后，写几个小程序，读取EXCEL里的控制信号序列，存到ROM1里，并把ROM2也调整好。
读取记事本里的汇编代码，生成对应的机器指令，存到RAM里。

打开记事本写一段汇编，运行，结果正确。至此，这个类似cpu的机器完成了。
