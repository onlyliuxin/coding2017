1、尾递归
栈帧。

函数递归使用栈帧来实现的。栈帧是帧，本质是一段记录了递归调用的必要信息的片段。



栈帧

返回值
返回地址


栈帧1

栈帧2

栈帧3

栈帧4

栈帧5


返回值6*f(5)
返回地址



返回值5*f(4)
返回地址



返回值4*f(3)
返回地址



返回值3*f(2)
返回地址



返回值2*f(1)
返回地址


共有5个栈帧，每个栈帧都会指向之前调用自己的栈帧。如果是求f(n)，n是一个很大的值，那么存储栈帧的栈内存很可能会溢出。为了防止溢出，有一种尾递归的方法。

上边的5个栈帧存储了两个重要信息：返回值和返回地址。因为调用的函数f()都是一样的，信息中不同的只有前面的系数和后边的返回地址。如果可以将不同信息都变成相同信息，那么久只用一个栈帧，返回地址还指向自己，就可以了。
这样的话，就是讲f()前面的系数去掉，那么放在哪里呢？哪里都不能，因为为了保持每次调用的栈帧存储的信息都相同。为了这样，只能在系数写进f（）函数 里，变成f（）的参数。也就是说f（n-1,n*result），其中result就是本次调动f的系数。
这样所有的栈帧就都存储了相同的信息。相同的函数f（）和相同的返回地址（指向自己）。
但是这样不就会让下一次的调用覆盖掉本次调用了么，那么即便计算出调用结果，上一次的已经被覆盖掉了，还怎么使用呢。
为了解释这一点，要理解，因为该栈帧只调用了自己，所以如果把自己求出来了，那么无需再保存什么别的东西了。
比如说：


返回值f(5，1)
返回地址



返回值f(4,2)
返回地址



返回值f(3,2)
返回地址

2、sync是同步的意思，同步有两个方向。到底向哪个方向同步，需要看commit在哪端。
这里又涉及到了commit概念。
commit表示——将更改记录先来，一条更改（删除，添加）就是一个commit，commit记录了在本地或者远端的所有操作。
因此，sync同步就可以依照commit来进行。如果本地发生了commit，sync就是将远端与本地文件进行同步，对本地来讲是一个上传的过程；如果是远端进行了commit，那么sync就是讲远端文件下载到本地，对本地来讲就是下载过程。

当然也可以不讲所有commit进行同步，允许选择一些commit进行同步。比如，你只想将某一些文件上传到远端，而另外一写不想。

3、Pull requests的字面意思是“拉请求”。它操作的对象是fork的源端和子端，也就是链接作者和我自己。
这个操作的意思是，该请求将一方仓库中的改变（commit）拉到另一方的仓库中去，实现合并的作用。作用有两点：1、是将你所做的贡献(commit)交给作者，期望作者能够将你的代码拉（pull）到作者的仓库中，实现合并。2、是作者的仓库更改了许多代码，而自己的仓库与作者已经大相径庭，为了能持续跟踪作者的代码更新，我需要将作者的仓库与自己的同步更改。这就需要将作者的更改（commit）拉（pull）到自己的仓库中。


在Github中，pull requests操作这几两个参数，是右边的仓库中的commit会被拉倒左边的仓库总。所以，作者的仓库和自己的仓库哪个在左边呢个在右边需要根据需求来确定。
